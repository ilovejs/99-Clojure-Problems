<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1433828456308">{:repl-history {:ide [], :local [&quot; (println \&quot;haha\&quot;)&quot; &quot;(print \&quot;haha\&quot;)&quot; &quot;(print \&quot;haha\&quot;)\n&quot; &quot;(last [1 2 3 4])&quot; &quot; (last [1 2 3 4])&quot; &quot;(len [1 2 3])&quot; &quot;(defn secondLast [lst]  \n   (let i (count lst)\n          (nth (- i) lst)))\n (secondLast [1 2 3 4])&quot; &quot; (defn secondLast [lst]\n   (let [i (count lst)]\n          (nth (- i) lst)))\n (secondLast [1 2 3 4])&quot; &quot;(defn secondLast [lst]\n  (let [i (count lst)]\n    (nth (- i) lst)))\n&quot; &quot;(- 3)&quot; &quot;(- 1 3)&quot; &quot;(defn secondLast [lst]\n  (let [i (count lst)]\n    (nth (- i 1) lst)))\n(secondLast [1 2 3 4])&quot; &quot;(count [1 2 3])&quot; &quot;(nth 3 [1 2 3 4])&quot; &quot;(defn secondLast [lst]\n  (let [i (count lst)]\n    (nth lst (- i 1))))\n(secondLast [1 2 3 4])&quot; &quot;(defn secondLast [lst]\n  (let [i (count lst)]\n    (nth lst (- i 2))))\n(secondLast [1 2 3 4])&quot; &quot;(nth [1 2 3] 3)&quot; &quot;(revese [1 2 3])&quot; &quot;(reverse [1 2 3])&quot; &quot;\n;6 Find out whether a list is a palindrome.\n (defn palindrome [lst]\n   (if (= lst (reverse lst))\n     1 0))\n (palindrome \&quot;12321\&quot;)&quot; &quot;(defn palindrome [lst]\n   (if (= lst (reverse lst))\n     1 0))\n &quot; &quot;(define lst \&quot;12321\&quot;)&quot; &quot;(def a \&quot;12321\&quot;)&quot; &quot;(= a (reverse \&quot;12321\&quot;))&quot; &quot; (defn palindrome [lst]\n   (if (= lst (reverse lst))\n     1 0))&quot; &quot;(if true 1 0)&quot; &quot;(if (true) 1 0)&quot; &quot;\n;6 Find out whether a list is a palindrome.\n (defn palindrome [lst]\n   (if (true? (= lst (reverse lst))) \n     1 0))&quot; &quot;(if (true? (= lst (reverse lst)))\n  1 0))\n&quot; &quot;lst&quot; &quot;(def lst \&quot;12321\&quot;)&quot; &quot;(if (true? (= lst (reverse lst)))\n  1 0)\n&quot; &quot;(true? (= lst (reverse lst)))\n  \n&quot; &quot;((= lst (reverse lst)))\n  \n&quot; &quot;(= lst (reverse lst))&quot; &quot;(reverse lst)&quot; &quot;(str (\\1 \\2 \\3 \\2 \\1))&quot; &quot;(map-cat (\\1 \\2 \\3 \\2 \\1))&quot; &quot;(map str (\\1 \\2 \\3 \\2 \\1))&quot; &quot;(map concat (\\1 \\2 \\3 \\2 \\1))&quot; &quot;(= [1 2 3 2 1] (reverse [1 2 3 2 1]))&quot; &quot;(reduce str (\\1 \\2))&quot; &quot;(apply str (1 2))&quot; &quot;(str 1 2)&quot; &quot;(concat 1 2)&quot; &quot;(concat \&quot;1\&quot; \&quot;2\&quot;)&quot; &quot;(apply str (\\1 \\2))&quot; &quot;(reverse \&quot;a2\&quot;)&quot; &quot;(apply str (\\a \\b))&quot; &quot;(apply str '(\\a \\b))&quot; &quot;(reverse \&quot;123\&quot;) == (\\1 \\2 \\3)&quot; &quot;(reverse \&quot;123\&quot;) == '(\\1 \\2 \\3)&quot; &quot;(defn palindrome [lst]\n   (if (true? (= lst (reverse lst)))\n     1 0))&quot; &quot;(if = ((reverse \&quot;123\&quot;)) '(\\1 \\2 \\3))&quot; &quot;\n(if = (reverse \&quot;123\&quot;) '(\\1 \\2 \\3))  \n&quot; &quot;\n(if (= (reverse \&quot;123\&quot;) \n       '(\\1 \\2 \\3)))&quot; &quot;\n(true? (= (reverse \&quot;123\&quot;) \n       '(\\1 \\2 \\3)))  \n&quot; &quot;(true? false)&quot; &quot;(true? (false))&quot; &quot;(true? (= (reverse \&quot;123\&quot;)\n       '(\\1 \\2 \\3)))&quot; &quot;\n(true? (= (reverse \&quot;123\&quot;)\n          (\\1 \\2 \\3)))&quot; &quot;(= (reverse \&quot;123\&quot;)\n   (\\1 \\2 \\3))&quot; &quot;(= (reverse \&quot;123\&quot;)\n   '(\\1 \\2 \\3))&quot; &quot;(true? (= (reverse \&quot;123\&quot;)\n          '(\\1 \\2 \\3)))&quot; &quot;(true? (= (reverse \&quot;12321\&quot;)\n          '(\\1 \\2 \\3 \\2 \\1)))&quot; &quot;(defn palindrome [lst]\n  (= lst (apply str (reverse lst))))&quot; &quot;(defn palindrome [lst]\n  (= lst (apply str (reverse lst))))\n\n(palindrome \&quot;12321\&quot;)\n&quot; &quot;(defn palindrome [lst]\n  (= lst (apply str (reverse lst))))\n&quot; &quot;(palindrome \&quot;12321\&quot;)&quot; &quot;(flatten ((1,1), 2, (3, (5,8))))&quot; &quot;(flatten (1 2 3))&quot; &quot;(flatten [1 [2 3]])&quot; &quot;(flatten [1 2 3])&quot; &quot;(flatten '( '(1,1), 2, '(3, '(5,8))))&quot; &quot;(flatten '(1 2))&quot; &quot;(flatten '(1 '(2,3)))&quot; &quot;(flatten '(1 '(2,3), 2))&quot; &quot;(flatten '(1 (2,3), 2))&quot; &quot;(flatten '((1,1), 2, (3, (5,8))))&quot; &quot;(defn pack [lst]\n  (take-while (fn [a b] (= a b))\n              lst))&quot; &quot;(take-while (fn [a b] (= a b))\n            [1 1 2 3])&quot; &quot;(take-while (partial &gt; 1000) (iterate inc 0))&quot; &quot;(take-while (partial &gt; 10) (iterate inc 0))&quot; &quot;(take-while (partial\n              (fn [a b] (= a b))\n              )\n            lst)&quot; &quot;(take-while (partial\n              (fn [a b] (= a b))\n              lst)\n            lst)&quot; &quot;(defn pack [lst]\n  (take-while (partial\n                (fn [a b] (= a b))\n                lst)\n              lst))&quot; &quot;(defn pack [lst]\n  (take-while (partial\n                (fn [a b] (= a b))\n                )\n              lst))&quot; &quot;\n(defn pack [lst]\n  (partition-by #(= %1 %2) lst))&quot; &quot;(pack [1 1 2 3 4 5 6 5 5 1])&quot; &quot;(cons [2 3] 1)&quot; &quot;(cons 1 [2 3])&quot; &quot;\n(defn pack [lst]\n  (cond\n    (nil? lst) nil\n    :else (let [head (first lst)]\n            (cons\n              head (recur\n                     (drop-while #(= % head) (rest lst)))))))&quot; &quot;(drop-while #(= % 1) (rest [1 2 3]))&quot; &quot;(identity (2 3))&quot; &quot;(identity '(2 3))&quot; &quot;(defn comb [sofar v n]\n  (if (= n 0)\n    (print sofar)\n    (for [i (range 0 (count v))]\n      (comb  (str sofar (nth v i))   ;don't it need to be recur ?\n             (subvec v (inc i))\n             (dec i)))))\n&quot; &quot;(comb \&quot;\&quot; [\\a \\b \\c] 3 )&quot;], :remote []}}</component>
</project>

